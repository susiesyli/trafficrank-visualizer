
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TrafficRank Visualization</title>
  <link rel="stylesheet" href="styles/main.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>TrafficRank Visualization</h1>
        <div class="iteration-label">Iteration 0</div>
        <div class="slider-container">
            <input type="range" id="slider" min="0" max="15" step="1" value="0">
            <button id="reset-button">Reset</button>
          </div>
        <svg id="graph"></svg>
    </div>
  
  <script>
    fetch('data/traffic.json')
      .then(response => response.json())
      .then(rankHistory => {
        const width = screen.width;
        const height = screen.height;

        const svg = d3.select('#graph')
            .attr('width', width)
            .attr('height', height);

        const g = svg.append('g');
        const numAreas = 77;

        // Initialize the simulation
        const simulation = d3.forceSimulation()
          .force('charge', d3.forceManyBody().strength(-1000)) // Reduce repulsion
          .force('center', d3.forceCenter(width / 2, height / 2)) // Center the graph
          .force('collision', d3.forceCollide(25)) // Closer nodes
          .force('link', d3.forceLink().distance(1)); // Shorter links

        // Create nodes array and initialize positions
        const nodes = Array.from({ length: numAreas }, (_, i) => ({
            id: i,
            rank: rankHistory[0].ranks[i], // Initialize with iteration 0 ranks
            x: Math.random() * width,
            y: Math.random() * height,
        }));

        // Create the links (for simplicity, connecting all nodes to each other)
        const links = [];
        for (let i = 0; i < numAreas; i++) {
          for (let j = i + 1; j < numAreas; j++) {
            links.push({ source: i, target: j });
          }
        }

        // Create link elements
        const link = g.selectAll('.link')
          .data(links)
          .enter()
          .append('line')
          .attr('class', 'link')
          .attr('stroke', "rgb(130,130,130)")
          .attr('stroke-opacity', 0.5)
          .attr('stroke-width', 0.15);

        // Create node elements
        const node = g.selectAll('.node')
          .data(nodes)
          .enter()
          .append('circle')
          .attr('class', 'node')
          .attr('r', d => d.rank * 500) // Scale size based on rank
          .attr('fill', "rgba(129,186,173, 1)")
          .call(d3.drag()  // Enable dragging of nodes
            .on('start', dragStart)
            .on('drag', dragged)
            .on('end', dragEnd));


        const text = g.selectAll('.label')
          .data(nodes)
          .enter()
          .append('text')
          .attr('class', 'label')
          .attr('font-size', '15px')
          .attr('fill', 'rgb(200,200,200)')
          .text(d => d.id)
          .attr('x', d => d.x + Math.pow(d.rank * 500)) // Offset based on node size
          .attr('y', d => d.y + Math.pow(d.rank * 500)); // Keep y unchanged

        // Update node and link positions on each iteration
        function updateGraph(rankData) {
          // Update ranks
          nodes.forEach((node, i) => {
            node.rank = rankData[i];
          });

          // Update node sizes
          node
            .transition()
            .duration(500)
            .attr('r', d => Math.sqrt(d.rank) * 50);

          // Update link positions
          link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

          // Update node positions
          node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

          // Update text positions
          text
            .attr('x', d => d.x + 10)
            .attr('y', d => d.y);
        }

        // Initialize simulation
        simulation
          .nodes(nodes)
          .on('tick', () => {
            // Update node and link positions on each tick
            link
              .attr('x1', d => d.source.x)
              .attr('y1', d => d.source.y)
              .attr('x2', d => d.target.x)
              .attr('y2', d => d.target.y);

            node
              .attr('cx', d => d.x)
              .attr('cy', d => d.y);

            text
              .attr('x', d => d.x + 10)
              .attr('y', d => d.y);
          });

        simulation.force('link').links(links);

        // Initialize graph with iteration 0
        updateGraph(rankHistory[0].ranks);

        // Update graph every 2 seconds
        let currentIteration = 0;
        let isPaused = false; // Flag to check if slider is in use

        // Function to update the graph for a specific iteration
        function updateGraphForIteration(iteration) {
            document.querySelector('.iteration-label').textContent = `Iteration ${iteration}`;
            updateGraph(rankHistory[iteration].ranks);
        }

        // Function to start the automatic animation
        // function startAutomaticAnimation() {
        //     setInterval(() => {
        //         if (!isPaused && currentIteration < rankHistory.length - 1) {
        //         currentIteration++;
        //         updateGraphForIteration(currentIteration);
        //         }
        //     }, 600);
        // }
        function startAutomaticAnimation() {
            const intervalId = setInterval(() => {
                if (!isPaused && currentIteration < rankHistory.length - 1) {
                    currentIteration++;
                    updateGraphForIteration(currentIteration);
                    
                    // Synchronize slider position with current iteration
                    slider.value = currentIteration;
                } else if (currentIteration >= rankHistory.length - 1) {
                    clearInterval(intervalId); // Stop the animation when reaching the end
                }
            }, 600);
        }

        // Start the automatic animation
        startAutomaticAnimation();

        // slider functionality
        const slider = document.getElementById('slider');
        slider.max = rankHistory.length - 1;

        slider.addEventListener('input', () => {
            isPaused = true; // Slider is being interacted with
            const iteration = parseInt(slider.value, 10);
            document.querySelector('.iteration-label').textContent = `Iteration ${iteration}`;
            updateGraph(rankHistory[iteration].ranks);
        });

        slider.addEventListener('change', () => {
            isPaused = false; // Slider interaction finished
        });

        // Reset button to restart the animation
        const resetButton = document.getElement('reset-button');
        // resetButton.textContent = 'Restart Animation';
        resetButton.addEventListener('click', () => {
            currentIteration = 0;
            slider.value = 0;
            isPaused = false;
            updateGraphForIteration(currentIteration);
            startAutomaticAnimation(); // Restart the animation
        });
        document.querySelector('.container').appendChild(resetButton);

        // Functions for dragging
        function dragStart(event, d) {
          d3.select(this).raise().attr('stroke', 'black');
        }

        function dragged(event, d) {
            d.x = event.x;
            d.y = event.y;
            simulation.alphaTarget(0.3).restart(); // Restart the simulation to reflect the new position
        }

        function dragEnd(event, d) {
            d3.select(this).attr('stroke', null);
        }
      })
      .catch(error => {
        console.error('Error loading the JSON file:', error);
      });
  </script>
</body>
</html>